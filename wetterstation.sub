#!/bin/bash
### Subroutinen V2.11.0 --------------------------------------------------------


 #Bezeichnung der Datenpunkte
  DP_TEMP_INNEN=${PRE_DP}.Innentemperatur
  DP_TEMP_AUSSEN=${PRE_DP}.Aussentemperatur
  DP_TAUPUNKT=${PRE_DP}.Taupunkt
  DP_WCHILL=${PRE_DP}.Gefuehlte_Temperatur
  DP_FEUCHTE_INNEN=${PRE_DP}.Innenfeuchtigkeit
  DP_FEUCHTE_AUSSEN=${PRE_DP}.Aussenfeuchtigkeit
  DP_WIND=${PRE_DP}.Wind
  DP_WIND_MAX=${PRE_DP}.Wind_max
  DP_WIND_DIR=${PRE_DP}.Windrichtung
  DP_WIND_DIR_TXT=${PRE_DP}.Windrichtung_Text
  DP_DRUCK_ABS=${PRE_DP}.Druck_absolut
  DP_DRUCK_REL=${PRE_DP}.Druck_relativ
  DP_REGENRATE=${PRE_DP}.Regenrate
  DP_REGENSTATUS=${PRE_DP}.Regenstatus
  DP_REGEN_TAG=${PRE_DP}.Regen_Tag
  DP_REGEN_WOCHE=${PRE_DP}.Regen_Woche
  DP_REGEN_MONAT=${PRE_DP}.Regen_Monat
  DP_REGEN_JAHR=${PRE_DP}.Regen_Jahr
  DP_REGEN_JAHR_KUM=${PRE_DP}.Regen_Jahr_kumuliert
  DP_SONNE=${PRE_DP}.Sonnenstrahlung
  DP_UV_INDEX=${PRE_DP}.UV_Index
  DP_UV_BELASTUNG=${PRE_DP}.UV_Belastung
  DP_ZEITSTEMPEL=${PRE_DP}.Zeitstempel
  DP_WETTER_TREND=${PRE_DP}.Wetter_Trend
  DP_WETTER_AKTUELL=${PRE_DP}.Wetter_aktuell
  DP_DRUCK_TENDENZ=${PRE_DP}.Druck_Tendenz
  DP_KOMFEHLER=${PRE_DP}._Kommunikationsfehler
  DP_WETTERDATA=${PRE_DP}.tempData.Wetterdaten
  DP_SONNENSCHEIN_SAVE=${PRE_DP}.tempData.Sonnenschein
  DP_SOLAR_SAVE=${PRE_DP}.tempData.Solarenergie
  DP_FW_UPGRADE=${PRE_DP}.Info.FW_Upgrade
  DP_FW_VERSION=${PRE_DP}.Info.FW_Version
  DP_OSEM_TRANSMIT=${PRE_DP}.Info.openSenseMap
  DP_WINDY_TRANSMIT=${PRE_DP}.Info.Windy
  DP_WCOM_TRANSMIT=${PRE_DP}.Info.Wetter_com
  DP_SONNENSCHEIN_VORTAG=${PRE_DP}.Info.Sonnenschein_VorTag
  DP_SONNENSCHEIN_TAG=${PRE_DP}.Info.Sonnenschein_Tag
  DP_SONNENSCHEIN_WOCHE=${PRE_DP}.Info.Sonnenschein_Woche
  DP_SONNENSCHEIN_MONAT=${PRE_DP}.Info.Sonnenschein_Monat
  DP_SONNENSCHEIN_JAHR=${PRE_DP}.Info.Sonnenschein_Jahr
  DP_SONNENSCHEIN_TAG_TEXT=${PRE_DP}.Info.Sonnenschein_Tag_Text
  DP_SONNENSCHEIN_WOCHE_TEXT=${PRE_DP}.Info.Sonnenschein_Woche_Text
  DP_SONNENSCHEIN_MONAT_TEXT=${PRE_DP}.Info.Sonnenschein_Monat_Text
  DP_SONNENSCHEIN_JAHR_TEXT=${PRE_DP}.Info.Sonnenschein_Jahr_Text
  DP_SONNENSCHEIN_VORJAHR=${PRE_DP}.Info.Sonnenschein_VorJahr
  DP_REGENMENGE_VORJAHR=${PRE_DP}.Info.Regenmenge_VorJahr
  DP_SOLARENERGIE_VORTAG=${PRE_DP}.Info.Solarenergie_VorTag
  DP_SOLARENERGIE_TAG=${PRE_DP}.Info.Solarenergie_Tag
  DP_SOLARENERGIE_WOCHE=${PRE_DP}.Info.Solarenergie_Woche
  DP_SOLARENERGIE_MONAT=${PRE_DP}.Info.Solarenergie_Monat
  DP_SOLARENERGIE_JAHR=${PRE_DP}.Info.Solarenergie_Jahr
  DP_SOLARENERGIE_VORJAHR=${PRE_DP}.Info.Solarenergie_VorJahr
  DP_LETZTER_REGEN=${PRE_DP}.Info.Letzter_Regen
  DP_LETZTE_REGENMENGE=${PRE_DP}.Info.Letzte_Regenmenge
  DP_STATION_BATTERIE=${PRE_DP}.Info.Station_Batteriestatus
  DP_WINDBOEEN_MAX=${PRE_DP}.Windboeen_max
  DP_REGEN_EVENT=${PRE_DP}.Regen_Event
  DP_REGEN_STUNDE=${PRE_DP}.Regen_Stunde
  DP_REGEN_TOTAL=${PRE_DP}.Regen_Total
  DP_GATEWAY_NAME=${PRE_DP}.Info.Wetterstation_Gateway
  DP_MIN_TEMP_24H=${PRE_DP}.Info.Temp_Aussen_24h_min
  DP_MAX_TEMP_24H=${PRE_DP}.Info.Temp_Aussen_24h_max
  DP_MIN_TEMP_HEUTE=${PRE_DP}.Info.Temp_Aussen_Heute_min
  DP_MAX_TEMP_HEUTE=${PRE_DP}.Info.Temp_Aussen_Heute_max
  DP_HITZEINDEX=${PRE_DP}.Info.Hitzeindex
  DP_MIN_TEMP_365D=${PRE_DP}.Info.Temp_Aussen_365t_min
  DP_MAX_TEMP_365D=${PRE_DP}.Info.Temp_Aussen_365t_max
  DP_AVG_TEMP_365D=${PRE_DP}.Info.Temp_Aussen_365t_avg
  DP_MET_SOMMER_TEMP=${PRE_DP}.Info.Temp_Met_Sommer_avg
  DP_MET_SOMMER_REGEN=${PRE_DP}.Info.Regenmenge_Met_Sommer
###  Ende Usereinstellungen


###-------------------------------------------------------------------------###
###  Subroutinen - KEINE ÄNDERUNGEN NÖTIG !                                 ###
###-------------------------------------------------------------------------###


###  Farbdefinition
      GR='\e[1;32m'
      GE='\e[1;33m'
      WE='\e[1;37m'
      BL='\e[1;36m'
      RE='\e[1;31m'
      NO='\e[0;39m'

###  Debugging
debuging() {

  #Messwerteblock
   echo -e "\n\n${WE}Messwerteblock: $GR${MESSWERTE[*]}$WE"

  #Datenfelder ausgeben
   echo -e "\n\nNicht alle Werte werden unterstützt (abhängig vom Modell der Wetterstation und dem verwendeten Protokoll)!"
   echo -e "\nTemperatur Innen\t: $GR${MESSWERTE[0]}$WE °C"
   echo -e "Temperatur Aussen\t: $GR${MESSWERTE[1]}$WE °C"
   echo -e "Taupunkt\t\t: $GR${MESSWERTE[2]}$WE °C"
   echo -e "Gefühlte Temperatur\t: $GR${MESSWERTE[3]}$WE °C"
   echo -e "Luftfeuchte Innen\t: $GR${MESSWERTE[4]}$WE %"
   echo -e "Luftfeuchte Aussen\t: $GR${MESSWERTE[5]}$WE %"
   echo -e "Windgeschwindkeit\t: $GR${MESSWERTE[6]}$WE km/h"
   echo -e "Windböengeschwindkeit\t: $GR${MESSWERTE[7]}$WE km/h"
   echo -e "max. Windböe\t\t: $GR${MESSWERTE[21]}$WE km/h"
   echo -e "Windrichtung\t\t: $GR${MESSWERTE[8]}$WE °"
   echo -e "Windrichtung\t\t: $GR${WINDRICHTUNG}$WE"
   echo -e "Luftdruck absolut\t: $GR${MESSWERTE[9]}$WE hPa"
   echo -e "Luftdruck relativ\t: $GR${MESSWERTE[10]}$WE hPa"
   echo -e "Regenrate\t\t: $GR${MESSWERTE[11]}$WE mm/h"
   echo -e "Regenstatus\t\t: $GR${REGENSTATUS}$WE"
   echo -e "Regen seit Regenbeginn\t: $GR${MESSWERTE[22]}$WE mm"
   echo -e "Regen Stunde\t\t: $GR${MESSWERTE[23]}$WE mm"
   echo -e "Regen Tag\t\t: $GR${MESSWERTE[12]}$WE mm"
   echo -e "Regen Woche\t\t: $GR${MESSWERTE[13]}$WE mm"
   echo -e "Regen Monat\t\t: $GR${MESSWERTE[14]}$WE mm"
   echo -e "Regen Jahr\t\t: $GR${MESSWERTE[15]}$WE mm"
   echo -e "Regen Gesamt\t\t: $GR${MESSWERTE[24]}$WE mm"
   echo -e "Sonnenstrahlung\t\t: $GR${MESSWERTE[16]}$WE W/m²"
   echo -e "UV-Index\t\t: $GR${MESSWERTE[17]}$WE"
   echo -e "Zeitstempel\t\t: $GR${MESSWERTE[18]}$WE" | sed -e 's/%20/ /g'
   echo -e "Firmware\t\t: $GR${MESSWERTE[19]}$WE"
   echo -e "Batteriestand:\t\t: $GR${MESSWERTE[20]}$WE"
   echo -e "Gateway-Modell\t\t: $GR${MESSWERTE[25]}$WE"

   echo -en "\nZusatzsensoren:"
   if [ $WS_PROTOKOLL = 1 ]; then echo -e "$GR keine $WE"; else echo -e "\n"; fi
   for ((i=31; i<$MAXDEVICES; i++))
   do
     if [ ! -z ${MESSWERTE[$i]} ]; then
        echo -en " \033[s ${MESSWERTE[$i]} \033[u"
        echo -e "\033[23C: $GR${MESSWERTE[$(($i+1))]}$WE"
     fi
     ((i++))
   done

   echo -e "\n\nDatenstring für ioBroker:\n$GR$IOB_DATA$WE\n"
   if [ "$show_pwid" = "true" ]; then
      DAT=$DATA
    else
      DAT=$(echo $DATA| sed -e 's/PASSWORD=.*[^&]*&indoort/PASSWORD=xxxxxx\&indoort/; s/\?ID=.*[^&]*&PASS/\?ID=xxxxxx\&PASS/; s/PASSKEY=.*[^&]*&stationtype/PASSKEY=xxxxxx\&stationtype/')
   fi
   echo -e "\nDATA von Wetterstation:\n$GR${DAT}$WE\n"

   echo -e "\nDebug VAR:"
   echo -e "Installationsverzeichnis: $GE$DIR$WE"
   echo -e "IPP: $GE${IPP}$WE\tWS_PORT: $GE${WS_PORT}$WE\t\tWS_POLL: $GE${WS_POLL}$WE\t\tPRE_DP: $GE${PRE_DP}$WE"
   echo -en "WEB: $GE${WEB}\t\t${WE}WS_PROT: $GE";
    case $WS_PROTOKOLL in
     1) echo -en "Wunderground";;
     2) echo -en "Ecowitt";;
     9) echo -en "Sainlogic Pro";;
     *) echo -en "unbekannt"
    esac
   echo -e "$WE\tDP40/50/60/70/100/200/250/300: $GE${ANZAHL_DP40} $WE| $GE${ANZAHL_DP50} $WE| $GE${ANZAHL_DP60} $WE| $GE${ANZAHL_DP70} $WE| $GE${ANZAHL_DP100} $WE| $GE${ANZAHL_DP200} $WE| $GE${ANZAHL_DP250} $WE| $GE${ANZAHL_DP300} $WE"
   echo -e "${WE}WH31: $GE${ANZAHL_WH31} $WE"
   echo -e "Script-Version: ${GE}${SH_VER}${WE}\tConfig-Version: $GE${CONF_V}$WE\tSub-Version: $GE${SUBVER}$WE"

   if [ ! -z "$KOMFEHLER" ]; then echo -e "\n${RE}Kommunikationsfehler!$WE\n"; fi
   if [ ! -z "$KOMFEHLER" ] && [ $WS_PROTOKOLL = 1 ]; then echo -e "\n${RE}Kommunikationsfehler! Stimmt die WS_ID in der Konfiguration mit der der WS View-App überein? $WE\n"; fi

   #API-Check
   if [ ! -z ${WETTERCOM_ID} ]; then wettercom_update; fi
   if [ ${use_windy} == "true" ]; then windy_update; fi
   if [ ${openSenseMap} == "true" ]; then opensensemap; fi

  #Shell-Skript mit Fehler beenden
    exit 1
}

###SAPI
function SAPI()
{
  #1 Single / Bulk
  #2 SAPI-URL
  #3 DATA (setBulk)

  if [ "$1" == "Single" ]; then
   retval=$(curl -s ${WEB}://${IPP}/${2}&user=${AUTH_USER}&pass=${AUTH_PASS} >/dev/null 2>&1)
  fi

  if [ "$1" == "Bulk" ]; then
   curl --data "${3}&user=${AUTH_USER}&pass=${AUTH_PASS}" ${WEB}://${IPP}/${2} >/dev/null 2>&1
  fi
}


### ioB-Daten senden
iob_send() {

    IOBPAR=(${DP_TEMP_INNEN} ${DP_TEMP_AUSSEN} ${DP_TAUPUNKT} ${DP_WCHILL} ${DP_FEUCHTE_INNEN} ${DP_FEUCHTE_AUSSEN} ${DP_WIND} ${DP_WIND_MAX} \
    ${DP_WIND_DIR} ${DP_DRUCK_ABS} ${DP_DRUCK_REL} ${DP_REGENRATE} ${DP_REGEN_TAG} ${DP_REGEN_WOCHE} ${DP_REGEN_MONAT} ${DP_REGEN_JAHR} \
    ${DP_SONNE} ${DP_UV_INDEX} ${DP_DP50_1_TEMP} ${DP_ZEITSTEMPEL} ${DP_FW_VERSION} ${DP_STATION_BATTERIE} ${DP_WINDBOEEN_MAX} ${DP_REGEN_EVENT} \
    ${DP_REGEN_STUNDE} ${DP_REGEN_TOTAL} ${DP_GATEWAY_NAME})

    IOBOUT=""
    #Standard DP für ioBroker
    for (( i = 0; i < 26; i++ )); do
       if [[ ! -z "${MESSWERTE[$i]}" ]]; then IOBOUT="${IOBOUT}&${IOBPAR[$i]}=${MESSWERTE[$i]}"; fi
    done

    #Sensoren DP/WH für ioBroker
    for (( i = 31; i < $MAXDEVICES; i+=2 )); do
      if [[ ! -z "${MESSWERTE[$i]}" ]]; then
         if [[ "${MESSWERTE[$i]}" =~ ^temp[1-8] ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP50.${MESSWERTE[$i]:4:1}.Temperatur=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^humidity[1-8] ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP50.${MESSWERTE[$i]:8:1}.Feuchtigkeit=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^batt[1-8] ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP50.${MESSWERTE[$i]:4:1}.Batterie=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^soilbatt[1-8] ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP100.${MESSWERTE[$i]:8:1}.Batterie=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^soilmoisture[1-8] ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP100.${MESSWERTE[$i]:12:1}.Bodenfeuchtigkeit=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" = "lightning" ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP60.1.Entfernung=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^lightning_num ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP60.1.Anzahl=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^lightning_time ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP60.1.Zeitpunkt=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^wh57batt ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP60.1.Batterie=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^pm25_ch[1-4] ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP200.${MESSWERTE[$i]:7:1}.PM25=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^pm25_avg_24h_ch[1-4] ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP200.${MESSWERTE[$i]:15:1}.PM25_24h=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^pm25batt[1-4] ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP200.${MESSWERTE[$i]:8:1}.Batterie=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^leak_ch[1-4] ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP70.${MESSWERTE[$i]:7:1}.Status=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^leakbatt[1-4] ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP70.${MESSWERTE[$i]:8:1}.Batterie=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^tf_co2 ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP250.1.Temperatur=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^humi_co2 ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP250.1.Luftfeuchtigkeit=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^pm25_co2 ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP250.1.PM25=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^pm25_24h_co2 ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP250.1.PM25_24h=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^pm10_co2 ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP250.1.PM10=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^pm10_24h_co2 ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP250.1.PM10_24h=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" = "co2" ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP250.1.CO2=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" = "co2_24h" ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP250.1.CO2_24h=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^co2_batt ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP250.1.Batterie=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^wh68batt ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP300.1.Batterie=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^wh26batt ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.DP40.1.Batterie=${MESSWERTE[$(($i+1))]}"; fi
         if [[ "${MESSWERTE[$i]}" =~ ^wh25batt ]]; then IOBOUT="${IOBOUT}&${PRE_DP}.WH31.1.Batterie=${MESSWERTE[$(($i+1))]}"; fi
      fi
    done
    IOBOUT="${IOBOUT:1}"

   #Leerzeichen entfernen + Zeitstempel/Regenstatus/UV-Belastung wg. Leerzeichen erst hier anhängen
    IOB_DATA=$(echo $IOBOUT|tr -d " ")
    IOB_DATA=${IOB_DATA}\&${DP_REGENSTATUS}=${REGENSTATUS}\&${DP_UV_BELASTUNG}=${UV_BELASTUNG}\&${DP_WIND_DIR_TXT}=${WINDRICHTUNG}\&${DP_HITZEINDEX}=${HITZEINDEX}

   #Daten an den ioB schicken
    if [ $debug == "true" ]; then
	curl --data "$IOB_DATA&user=${AUTH_USER}&pass=${AUTH_PASS}&prettyPrint" ${WEB}://${IPP}/setBulk
      else
	curl --data "$IOB_DATA&user=${AUTH_USER}&pass=${AUTH_PASS}" ${WEB}://${IPP}/setBulk >/dev/null 2>&1
    fi
}


### Daten holen und Integritätscheck
get_DATA() {
  case $WS_PROTOKOLL in
   1|9) DATA=$(timeout ${WARTE} nc -nlvw 1 -p ${WS_PORT} 2>/dev/null|sed -n '1 p')
        STRLEN=$(echo -n $DATA | wc -m)
       #haben wir eine Jahresregenmenge?
        if [[ ! "$DATA" =~ "yearlyrainin" ]]; then DATA=$(echo $DATA| sed -e 's/solarradiation/yearlyrainin=0\&solarradiation/' ); fi
       #haben wir überhaupt eine Regenmenge?
        if [[ ! "$DATA" =~ "rainin" ]]; then DATA=$(echo $DATA| sed -e 's/solarradiation/rainin=0\&solarradiation/' ); fi
       #check auf Datenintigrität
        if [ "$STRLEN" -gt "400" ] && [[ "$DATA" =~ "/weatherstation/updateweatherstation.php?ID=${WS_ID}" ]]; then return 0; else return 1; fi
       ;;

   2) DATA=$(timeout ${WARTE} nc -nlvw 1 -p ${WS_PORT} 2>/dev/null|tail -1)
      STRLEN=$(echo -n $DATA | wc -m)
      if [ "$STRLEN" -gt "150" ] && [[ "$DATA" =~ "PASSKEY=" ]] && [[ "$DATA" =~ "tempf=" ]]; then return 0; else return 1; fi
      ;;

   *) echo -e "\n${RE}Die Angabe: WS_PROTOKOLL=$WS_PROTOKOLL ist ungültig. Bitte die Eingabe in der wetterstation.conf korrigieren!$WE\n"
      #Shell-Skript mit Fehler beenden
      exit 1

  esac
}



### Datenpaket der Wetterstation anzeigen
ws_data() {
  case $WS_PROTOKOLL in
   1|9) echo -e "\n\nWarte maximal ${WARTE} Sekunden auf Datenpaket der Wetterstation...\n" && timeout ${WARTE} nc -nlvw 1 -p ${WS_PORT} | sed -n '1 p'
        ;;

   2)   echo -e "\n\nWarte maximal ${WARTE} Sekunden auf Datenpaket der Wetterstation...\n" && timeout ${WARTE} nc -nlvw 1 -p ${WS_PORT} | tail -1
        ;;

   *)   echo Protokollfehler...
        exit 1
  esac
  echo -e "\n"
}



### Datenkonvertierungen
convertFtoC() {
	MESSWERTE[$1]=`echo "scale=2;(${MESSWERTE[$1]}-32)*5/9" | bc -l`
}

convertMPHtoKMH() {
	MESSWERTE[$1]=`echo "scale=2;(${MESSWERTE[$1]}*16094/10000)" | bc -l`
}

convertLuftdruck() {
	MESSWERTE[$1]=`echo "scale=2;${MESSWERTE[$1]}*33864/1000" | bc -l`
}

convertInchtoMM() {
     MESSWERTE[$1]=`echo "scale=1;${MESSWERTE[$1]}*254/10" | bc -l`
      #Protokoll #9 liefert keine Regenrate(11); also alle Regenberechnungen überspringen
      if [ "$WS_PROTOKOLL" -ne "9" ]; then

        #Regenstatus bestimmen (#11)
	if [ "$1" -eq "11" ]; then
         ##if [ "$WS_PROTOKOLL" -eq "9" ] && [ -z ${MESSWERTE[11]} ]; then MESSWERTE[11]=0; fi
	 REGEN=$(round ${MESSWERTE[11]} 0)
	 if [ "$REGEN" -ge "10" ]; then REGENSTATUS="Starkregen"; fi
	 if [ "$REGEN" -lt "10" ]; then REGENSTATUS="starker Regen"; fi
	 if [ "$REGEN" -lt "4" ]; then REGENSTATUS="mäßiger Regen"; fi
	 if [ "$REGEN" -eq "1" ]; then REGENSTATUS="leichter Regen"; fi
	 if [ "$REGEN" -eq "0" ]; then REGENSTATUS="kein Regen"; fi
	fi

	#letztes Regenereignis + letzte Regenmenge
	if [ "$REGEN" -gt "0" ] && [ "$1" -eq "12" ]; then
	 AKT_TIMESTAMP=`date +%s`
	 if [ $LAST_RAIN == "DATUM" ]; then LASTRAINMSG=`date "+%d.%m.%Y %H:%M"`; fi
	 if [ $LAST_RAIN == "UNIX" ]; then LASTRAINMSG=${AKT_TIMESTAMP}; fi
	 SAPI "Bulk" "setBulk" "${DP_LETZTER_REGEN}=${LASTRAINMSG}&${DP_LETZTE_REGENMENGE}=${MESSWERTE[12]}"
	fi

	if [ $LAST_RAIN == "DIFF" ]; then
	   TS_AKT=$(date +%s)
           SAPI "Single" "get/${DP_REGENRATE}?prettyPrint"
           if [ -z "${retval}" ]; then return; fi                #Abbruch falls SimpleAPI nicht erreichbar
           LC=$(echo ${retval} | jq -r '.lc')
           LC=$(echo "scale=0;${LC}/1000" | bc -l)
           TS_DIFF=$(echo "${TS_AKT}-${LC}" | bc)
           TAGE=$(($TS_DIFF /86400))
	   case $TAGE in
		0)  STUNDEN=$(echo "$(($TS_DIFF /3600))")
		    if [ "$STUNDEN" -eq "1" ]; then
			LASTRAINMSG="vor einer Stunde"
		    else
		        LASTRAINMSG="vor $STUNDEN Stunden"
		    fi
		    if [ "$STUNDEN" -eq "0" ]; then LASTRAINMSG="gerade eben"; fi ;;
		1)  LASTRAINMSG="vor einem Tag" ;;
		*)  LASTRAINMSG="vor $TAGE Tagen"
	   esac
           SAPI "Bulk" "setBulk" "${DP_LETZTER_REGEN}=${LASTRAINMSG}"
	fi

      fi
}

convertTime() {
        MESSWERTE[$1]=$(echo ${MESSWERTE[$1]}|sed -e 's/+/ /' -e 's/%20/ /')
        if [[ ${MESSWERTE[$1]} == "now" ]]; then
                MESSWERTE[$1]=$(date --date="${MESSWERTE[$1]}" +'%d.%m.%Y %H:%M:%S')
        else
                MESSWERTE[$1]=$(date --date="${MESSWERTE[$1]} UTC" +'%d.%m.%Y %H:%M:%S')
        fi
        MESSWERTE[$1]=$(echo ${MESSWERTE[$1]}|sed -e 's/ /%20/')
	#MESSWERTE[$i]=$(echo ${MESSWERTE[$1]}|awk -F'-|%20' '{printf "%02s.%02s.%s %s", $3, $2, $1, $4}')
}



###Jahresregenmenge
rain() {
	   SAPI "Single" "get/${DP_REGEN_JAHR_KUM}?prettyPrint"
           LC=$(echo ${retval} | jq -r '.lc')
	   LC=`echo "scale=0;${LC}/1000" | bc -l`
	   TS_AKT=$(date +%s)
	   TS_DIFF=`echo "${TS_AKT}-${LC}-3600" | bc` #mind. 1 Stunde Differenz

	  if [ ${TS_DIFF} -ge "0" ]; then
           SAPI "Single" "getPlainValue/${DP_REGEN_JAHR_KUM}"
	   REGENMENGE=$(echo "scale=2;${retval}+${MESSWERTE[12]}" | bc -l)
	   SAPI "Single" "set/${DP_REGEN_JAHR_KUM}?value=${REGENMENGE}&ack=true"
	  fi
}



###Windrichtung als Text
winddir() {
   WINDRICHTUNG=${WINDDIRS[$(round ${MESSWERTE[$1]}/22.5 0)]}
}


### Batteriestatus als Text
batterie() {
   if [[ "MESSWERTE[$1]" -eq 0 ]]; then
      MESSWERTE[$1]="OK";
   else
      MESSWERTE[$1]="Alarm";
   fi
}



### Wasserleckalarm als Text
leakalarm() {
   if [[ "MESSWERTE[$1]" -eq 0 ]]; then
      MESSWERTE[$1]="normal";
   else
      MESSWERTE[$1]="Alarm";
   fi
}


###Wetterprognose
wetterprognose() {
	let TIMER_SET=$(date +%s)+90
	LUFTDRUCK=$(round ${MESSWERTE[10]} 0)

	#Array bilden
	DRUCKWERTE=(${DRUCKWERTE[@]:1})
	DRUCKWERTE[11]=$LUFTDRUCK

	#Tendenz berechnen
	if [ "${DRUCKWERTE[0]}" -gt "20" ]; then
	 let PNOW=($LUFTDRUCK-${DRUCKWERTE[0]})*10
	 if [ "$PNOW" -le "-80" ]; then WETTER_TREND="Sturm mit Hagel"; fi
	 if [ "$PNOW" -le "-50" ] && [ "$PNOW" -gt "-80" ]; then WETTER_TREND="Regen/Unwetter"; fi
	 if [ "$PNOW" -le "-30" ] && [ "$PNOW" -gt "-50" ]; then WETTER_TREND="regnerisch"; fi
	 if [ "$PNOW" -le "-5" ] && [ "$PNOW" -gt "-30" ]; then WETTER_TREND="baldiger Regen"; fi
	 if [ "$PNOW" -le "5" ] && [ "$PNOW" -gt "-5" ]; then WETTER_TREND="gleichbleibend"; fi
	 if [ "$PNOW" -le "30" ] && [ "$PNOW" -ge "5" ]; then WETTER_TREND="lange schön"; fi
	 if [ "$PNOW" -le "50" ] && [ "$PNOW" -ge "30" ]; then WETTER_TREND="schön & labil"; fi
	 if [ "$PNOW" -gt "50" ]; then WETTER_TREND="Sturmwarnung"; fi
	 PNOW=$(echo "scale=2;$PNOW/10" | bc -l)
	fi

	#Wetter erfassen und bestimmen
	 if [ "$LUFTDRUCK" -le "980" ]; then WETTER_AKTUELL="stürmisch, Regen"; fi
	 if [ "$LUFTDRUCK" -gt "980" ] && [ "$LUFTDRUCK" -le "1000" ]; then WETTER_AKTUELL="regnerisch"; fi
	 if [ "$LUFTDRUCK" -gt "1000" ] && [ "$LUFTDRUCK" -le "1020" ]; then WETTER_AKTUELL="wechselhaft"; fi
	 if [ "$LUFTDRUCK" -gt "1020" ] && [ "$LUFTDRUCK" -le "1040" ]; then WETTER_AKTUELL="sonnig"; fi
	 if [ "$LUFTDRUCK" -gt "1040" ]; then WETTER_AKTUELL="trocken, Gewitter"; fi


	#falls Initialisierung
	if [[ "$WETTER_TREND" =~ "Minuten" ]]; then
	 let RESTZEIT=15*${DRUCKWERTE[0]}
	 WETTER_TREND="dauert noch ${RESTZEIT} Minuten"
	fi

	#sicherstellen dass nur Zahlen im 2. Wert vorhanden sind
	#DRUCKWERTE[1]=$(echo ${DRUCKWERTE[1]} | grep -o '[0-9]*')

	#build Data-String
	IOB_WDATA=$(cat <<-EOD
	${DP_WETTER_TREND}=${WETTER_TREND}&${DP_DRUCK_TENDENZ}=${PNOW}&${DP_WETTER_AKTUELL}=${WETTER_AKTUELL}&${DP_WETTERDATA}=${DRUCKWERTE[*]}
	EOD
	)

    SAPI "Bulk" "setBulk" "${IOB_WDATA}"

}



###Check auf Firmwareupgrade
firmware_check() {
	#Version auf GitHub holen
	FW_VER=$(curl -s https://raw.githubusercontent.com/SBorg2014/WLAN-Wetterstation/master/firmware.version)
	FW_AKT=${MESSWERTE[19]}

	if [ "$FW_VER" != "$FW_AKT" ]; then
	  SAPI "Single" "set/${DP_FW_UPGRADE}?value=true&ack=true"
	 else
	  SAPI "Single" "set/${DP_FW_UPGRADE}?value=false&ack=true"
	fi
	SAPI "Single" "set/${DP_FW_VERSION}?value=${FW_AKT}&ack=true"
}



###Sonnenscheindauer (>=120W/m²) / Solarenergie
sonnenpuls() {
    SONNEN_STRAHLUNG=$(round ${MESSWERTE[$1]} 0)
    if [ "$SONNEN_STRAHLUNG" -ge "120" ] || [ ! -z "$MIDNIGHTRUN" ]; then
	AKT_TIMESTAMP=$(date +%s)
	let SONNENPULS_DIFF=${AKT_TIMESTAMP}-${TIMER_START}
	if [ "$SONNENPULS_DIFF" -lt "300" ]; then
	 let SONNENSCHEIN_TAG+="$SONNENPULS_DIFF"
	 let SONNENSCHEIN_WO+="$SONNENPULS_DIFF"
	 let SONNENSCHEIN_MO+="$SONNENPULS_DIFF"
	 let SONNENSCHEIN_JAHR+="$SONNENPULS_DIFF"
	fi
	SAPI "Bulk" "setBulk" "${DP_SONNENSCHEIN_SAVE}=${SONNENSCHEIN_TAG} ${SONNENSCHEIN_WO} ${SONNENSCHEIN_MO} ${SONNENSCHEIN_JAHR}"
	timestr ${SONNENSCHEIN_TAG} SONNENDAUER_STR_TAG
	timestr ${SONNENSCHEIN_WO} SONNENDAUER_STR_WO
	timestr ${SONNENSCHEIN_MO} SONNENDAUER_STR_MO
	timestr ${SONNENSCHEIN_JAHR} SONNENDAUER_STR_JAHR

	#build + send Data-String
	IOB_SDATA=$(cat <<-EOD
	${DP_SONNENSCHEIN_TAG_TEXT}=${SONNENDAUER_STR_TAG}&${DP_SONNENSCHEIN_WOCHE_TEXT}=${SONNENDAUER_STR_WO}&${DP_SONNENSCHEIN_MONAT_TEXT}=${SONNENDAUER_STR_MO}&${DP_SONNENSCHEIN_JAHR_TEXT}=${SONNENDAUER_STR_JAHR}&${DP_SONNENSCHEIN_TAG}=${SONNENSCHEIN_TAG}&${DP_SONNENSCHEIN_WOCHE}=${SONNENSCHEIN_WO}&${DP_SONNENSCHEIN_MONAT}=${SONNENSCHEIN_MO}&${DP_SONNENSCHEIN_JAHR}=${SONNENSCHEIN_JAHR}
	EOD
	)
	if [ -z $MIDNIGHTRUN ]; then TIMER_START=`date +%s`; fi
	SAPI "Bulk" "setBulk" "${IOB_SDATA}"
    fi

	###Solarenergie
    if [ "$SONNEN_STRAHLUNG" -gt "0" ] || [ ! -z "$MIDNIGHTRUN" ]; then
	#Arrays bilden / TS=Zeitstempel
	SOLARENERGIE=(${SOLARENERGIE[@]:1})
	SOLARENERGIE_TS=(${SOLARENERGIE_TS[@]:1})
	SOLARENERGIE[1]=$SONNEN_STRAHLUNG
	SOLARENERGIE_TS[1]=$(date +%s)

	#Mittelwert berechnen
	SOL_TMP=$(echo "scale=2;(${SOLARENERGIE[0]}+${SOLARENERGIE[1]})/2" | bc -l)

        #Zeitdifferenz zwischen 2 Messungen ermitteln
        let "ZEIT_DIFF = ${SOLARENERGIE_TS[1]} - ${SOLARENERGIE_TS[0]}"

        #bei einer Differenz >= 5 Minuten gehen wir von einem "fail" aus (Start des Skriptes, Wolken...)
        if [ "$ZEIT_DIFF" -ge "300" ]; then ZEIT_DIFF=${WS_POLL}; fi

	#Leistung berechnen
	SOL_TMP=$(echo "scale=3;${SOL_TMP}/(3600/${ZEIT_DIFF})" | bc -l)
	SOLARENERGIE_TAG=$(echo "scale=3;${SOLARENERGIE_TAG}+${SOL_TMP}" | bc -l)
	SOLAR_WOCHE=$(echo "scale=5;(${SOLAR_WOCHE}+${SOL_TMP})" | bc -l)
	SOLARENERGIE_WOCHE=$(echo "scale=3;${SOLAR_WOCHE}/1000" | bc -l) #Umrechnung in kWh
	SOLAR_MONAT=$(echo "scale=5;(${SOLAR_MONAT}+${SOL_TMP})" | bc -l)
	SOLARENERGIE_MONAT=$(echo "scale=3;${SOLAR_MONAT}/1000" | bc -l) #Umrechnung in kWh
	SOLAR_JAHR=$(echo "scale=5;(${SOLAR_JAHR}+${SOL_TMP})" | bc -l)
	SOLARENERGIE_JAHR=$(echo "scale=3;${SOLAR_JAHR}/1000" | bc -l)   #Umrechnung in kWh

	#Daten für ioB fertig machen
	IOB_SOLDATA=$(cat <<-EOD
	${DP_SOLARENERGIE_TAG}=${SOLARENERGIE_TAG}&${DP_SOLARENERGIE_WOCHE}=${SOLARENERGIE_WOCHE}&${DP_SOLARENERGIE_MONAT}=${SOLARENERGIE_MONAT}&${DP_SOLARENERGIE_JAHR}=${SOLARENERGIE_JAHR}&${DP_SOLAR_SAVE}=${SOLARENERGIE_TAG} ${SOLAR_WOCHE} ${SOLAR_MONAT} ${SOLAR_JAHR}
	EOD
	)

	SAPI "Bulk" "setBulk" "${IOB_SOLDATA}"
    fi

}



###UV-Belastung
uv_belastung() {
	UV_TMP=$(round ${MESSWERTE[$1]} 0)
	case ${UV_TMP} in
	   0)      UV_BELASTUNG="keine" ;;
	   1|2)    UV_BELASTUNG="gering" ;;
	   3|4|5)  UV_BELASTUNG="mittel" ;;
	   6|7)    UV_BELASTUNG="hoch" ;;
	   8|9|10) UV_BELASTUNG="sehr hoch" ;;
	   *)      UV_BELASTUNG="--"
	esac
	if [ "${UV_TMP}" -ge "11" ]; then UV_BELASTUNG="extrem hoch"; fi
}



###Hilfsfunktionen
timestr() {
	TAGE=$(echo "$(($1 /86400))")
	STUNDEN_KPL=$(echo "$(($1 /3600))")
	STUNDEN=$(echo "$(($1 % 86400 /3600))")
	MINUTEN=$(echo "$(($1 % 3600 /60))")
	SEKUNDEN=$(echo "$(($1 % 60))")

	if [ "$TAGE" -eq "1" ]; then TAG_TXT="Tag"; else TAG_TXT="Tage"; fi

	case ${SONNENSCHEIN_TXTFORMAT} in
	   0)   printf -v $2 "%d Std. %02d Min. %02d Sek." $STUNDEN_KPL $MINUTEN $SEKUNDEN ;;
	   1)   printf -v $2 "%d:%02d" $STUNDEN_KPL $MINUTEN ;;
	   2)   printf -v $2 "%d $TAG_TXT %d Std." $TAGE $STUNDEN ;;
	   3)   if [ "$TAGE" -eq "0" ]; then
	          printf -v $2 "%d Std, %d Min" $STUNDEN $MINUTEN
	         else
	          printf -v $2 "%d $TAG_TXT, %d Std, %d Min" $TAGE $STUNDEN $MINUTEN
	        fi ;;
	   *)   printf -v $2 "unbekanntes Format"
	esac
}


round() {
    bc -l <<END_BC
        define round(number,r_scale)
        {
            auto o_scale
            o_scale = scale
            scale = r_scale+1
            number += 5 / (10 ^ scale)
            scale = r_scale
            number /= 1
            scale = o_scale
            return number
        }
        round ($1,$2)
END_BC
}

reset_zaehler() {
	#VorZaehler aktualisieren
	SAPI "Single" "set/${DP_SONNENSCHEIN_VORTAG}?value=${SONNENSCHEIN_TAG}&ack=true"
	SAPI "Single" "set/${DP_SOLARENERGIE_VORTAG}?value=${SOLARENERGIE_TAG}&ack=true"

	#Tageszähler resetten
	SONNENSCHEIN_TAG=0
	SOLARENERGIE_TAG=0
	SOLARENERGIE=(0 0)
	SOLARENERGIE_TS=(0 0)
	TIMER_START=0

	#Wochenzähler resetten (Sonntags um 0:00 Uhr)
	if [ `date +%u` -eq "7" ]; then
	   SONNENSCHEIN_WO=0
	   SOLAR_WOCHE=0
	fi

	#Monatszähler resetten
	if [ $(date -d "now + 1 day" +"%d") -eq "01" ]; then
	  SONNENSCHEIN_MO=0
	  SOLAR_MONAT=0
	  if [ `date +%m` -eq "12" ]; then
		#Jahreszähler resetten
		SAPI "Single" "set/${DP_REGENMENGE_VORJAHR}?value=${REGENMENGE}&ack=true"
		SAPI "Single" "set/${DP_SONNENSCHEIN_VORJAHR}?value=${SONNENSCHEIN_JAHR}&ack=true"
		SAPI "Single" "set/${DP_SOLARENERGIE_VORJAHR}?value=${SOLAR_JAHR}&ack=true"
		REGENMENGE=0
	        SAPI "Single" "set/${DP_REGEN_JAHR_KUM}?value=${REGENMENGE}&ack=true"
		SONNENSCHEIN_JAHR=0
		SOLAR_JAHR=0
	        SAPI "Single" "set/${DP_MET_SOMMER_TEMP}?value=&ack=true"
	        SAPI "Single" "set/${DP_MET_SOMMER_REGEN}?value=&ack=true"
	  fi
	fi

	MIDNIGHTRUN=1; sonnenpuls 16
}

setup() {
  let "WARTE=WS_POLL*2+6"    #2x Poll + Zuschlag warten
  TIMER_SET=$(date +%s)      #Initial Set
  TIMER_START=0              #Reset Sonnenpuls
  #Anzeige bis Daten komplett
  WETTER_TREND="noch --- Minuten"

  declare -a MESSWERTE
  SOLARENERGIE=(0 0)
  SOLARENERGIE_TS=(0 0)
  DRUCKWERTE=(12 11 10 9 8 7 6 5 4 3 2 1)
  WINDDIRS=(N NNO NO ONO O OSO SO SSO S SSW SW WSW W WNW NW NNW N)

 #Check ob Pollintervall größer 16 Sekunden
  if [ ${WS_POLL} -lt "16" ]; then WS_POLL=16; fi

 #Anzahl der DP Berechnen
  case $WS_PROTOKOLL in
   1) MAXDEVICES=22;;
   *) MAXDEVICES=$(( 31 + $ANZAHL_DP40 * 2 + $ANZAHL_DP50 * 6 + $ANZAHL_DP100 * 4 + $ANZAHL_DP60 * 8 + $ANZAHL_DP200 * 6 + $ANZAHL_DP70 * 4 + $ANZAHL_DP250 * 18 + $ANZAHL_DP300 *2 ))
      MAXDEVICES+=$(( $ANZAHL_WH31 * 2 ))
  esac

 #falls reboot warten bis der ioB wieder läuft...
  while ! nc -nvz $(echo $IPP|sed -e 's/:/ /'); do sleep 30; done

 #Fehlermeldungen resetten
  SAPI "Single" "set/${DP_KOMFEHLER}?value=false&ack=true"

 #Wetterdatenarray lesen
  SAPI "Single" "getPlainValue/${DP_WETTERDATA}"
  DRUCKWERTE_TMP=$(echo $retval | sed -e 's/\"//g' | tr -d '\\')

 if [ ${#DRUCKWERTE_TMP} -le "2" ]; then
   DRUCKWERTE_TMP=${DRUCKWERTE[*]}
   SAPI "Bulk" "setBulk" "${DP_WETTERDATA}=${DRUCKWERTE_TMP}"
  else
   SAPI "Single" "get/${DP_WETTERDATA}?prettyPrint"
   LC=$(echo $retval | jq -r '.lc')
   LC=`echo "scale=0;${LC}/1000" | bc -l`
   TS_AKT=$(date +%s)
   TS_DIFF=`echo "${TS_AKT}-${LC}-3600" | bc` #mind. 1 Stunde Differenz (dann >0)
   if [ "$TS_DIFF" -le "0" ]; then
     IFS=" "
     DRUCKWERTE=(${DRUCKWERTE_TMP[*]})
     if [ "${DRUCKWERTE[1]}" -gt "20" ]; then WETTER_TREND="dauert max. $(( 15 - (`date +%-M` % 15) )) Minuten"; fi
   fi
 fi

   #Sonnenscheinarray lesen
   SAPI "Single" "getPlainValue/${DP_SONNENSCHEIN_SAVE}"
   SONNENSCHEIN_TMP=$(echo ${retval}|sed -e 's/\"//g')
   IFS=" "
   SON_ARY=($SONNENSCHEIN_TMP)
	SONNENSCHEIN_TAG=${SON_ARY[0]}
	SONNENSCHEIN_WO=${SON_ARY[1]}
	SONNENSCHEIN_MO=${SON_ARY[2]}
	SONNENSCHEIN_JAHR=${SON_ARY[3]}

   #Solarenergiearray lesen
   SAPI "Single" "getPlainValue/${DP_SOLAR_SAVE}"
   SOLAR_TMP=$(echo ${retval}|sed -e 's/\"//g')
   SOL_ARY=($SOLAR_TMP)
	SOLARENERGIE_TAG=${SOL_ARY[0]:-0}
	SOLAR_WOCHE=${SOL_ARY[1]:-0}
	SOLAR_MONAT=${SOL_ARY[2]:-0}
	SOLAR_JAHR=${SOL_ARY[3]:-0}

   unset SOL_ARY; unset SON_ARY; unset SONNENSCHEIN_TMP; unset SOLAR_TMP

   #Startwerte setzen
   SAPI "Bulk" "setBulk" "${DP_WETTER_TREND}=${WETTER_TREND}"
}


###Befehlszeilenparameter
usage() {
	echo -e "\nusage: wetterstation [[--debug] | [-s|--show] | [-d|--data] | [--metsommer]"
        echo -e "       [--osem_reg] | [--windy_reg] | [-v|--version] | [-h|--help]]\n"
	echo -e " --debug\teinmaliger Testdurchlauf mit Ausgabe"
        echo -e " --metsommer\tführt die Berechnung des meteorologischen Sommers durch"
	echo -e " --osem_reg\tführt Registrierung bei openSenseMap durch"
        echo -e " --windy_reg\tführt Registrierung bei Windy durch"
	echo -e " -s | --show\tzeigt bei der Debug-Ausgabe Passwort/Station-ID bzw. Passkey im Klartext an"
	echo -e " -d | --data\tzeigt nur das gesendete Datenpaket der Wetterstation an"
	echo -e " -v | --version\tAusgabe der Versionsnummer und Prüfung der Abhängigkeiten"
	echo -e " -h | --help\tdieses Hilfemenue\n"
}

version() {
        clear
	echo -e "\n$BL WLAN-Wetterstation ${SH_VER} - (c)2019-2021 by SBorg"
	echo -e " Config-Version: ${CONF_V}"
	echo -e " Sub-Version   : ${SUBVER}\n"

        #Test ob bc,jq und netcat installiert sind
         if [ $(which bc) ]; then
           echo -e " $GR'bc'$WE installiert: $WE[$GR✓$WE]"
          else
           echo -e " $GR'bc'$WE installiert: $WE[$RE✗$WE]"
         fi
         if [ $(which jq) ]; then
           echo -e " $GR'jq'$WE installiert: $WE[$GR✓$WE] \n"
          else
           echo -e " $GR'jq'$WE installiert: $WE[$RE✗$WE] \n"
         fi

         if [[ $(sudo update-alternatives --query nc|grep Value) =~ openbsd ]]; then
              echo -e " $GR'nc'$WE in der Openbsd-Variante installiert:  $WE[$GR✓$WE]"
              echo -e " $GR'netcat'$WE in Openbsd-Variante aktiv, alles korrekt $WE[$GR✓$WE]"
          else
           if [[ $(sudo update-alternatives --query nc|grep openbsd) ]]; then
            echo -e " $GR'nc'$WE in der Openbsd-Variante installiert aber nicht aktiviert.\n"
            echo -e " Auswahl über die entsprechende Nummer aktivieren: \n"
            sudo update-alternatives --config nc
           else
            echo -e "${RE} ┌────────────────────────────────────────────────────────────┐"
            echo -e " │                                                            │"
            echo -e " │  ${WE}\"netcat\" ist nicht in der benötigten Version installiert!${RE} │"
            echo -e " │                                                            │"
            echo -e " │    ${WE}Soll er nun installiert werden? [${GR}J/N${WE}]\033[s                  ${RE} │"
            echo -e " │                                                            │"
            echo -e " └────────────────────────────────────────────────────────────┘"
            echo -en "\033[u"
             read -n 1 -p ": " JN
             if [ "$JN" = "J" ] || [ "$JN" = "j" ]; then
               echo -e "\n\n\n"
               sudo apt-get install netcat-openbsd
             else
               echo -e " $RE Abbruch... ${WE}\n\n\n"
               exit
             fi
            fi
          fi
         echo -e "\n"

}


opensensemap() {
	let ii=0
	unset OSeM_DATA
	for i in "${SENSEBOX_IDSENSOR[@]}"
	do
		OSeM_DATA="${OSeM_DATA}{\"sensor\":\"${i}\", \"value\":\"${MESSWERTE[${SENSEBOX_IDMESSWERT[ii]}]}\"}"
		let ii++
	done

	OSeM_DATA=$(echo $OSeM_DATA | sed "s/}{/},{/g" )
        if [ $debug == "true" ]; then
           echo -e "\n\n${BL}Datenübertragung an OpenSenseMap:${NO}"
 	   curl -H "Content-Type: application/json" -H "Authorization: ${BOX_TOKEN}" -d "[ ${OSeM_DATA} ]" https://api.opensensemap.org/boxes/${senseBox_ID}/data
           echo -e "\n"
           return 0 #Ausgang
         else
 	   OSEM_TRANSMIT=$(curl -s -H "Content-Type: application/json" -H "Authorization: ${BOX_TOKEN}" \
           -d "[ ${OSeM_DATA} ]" https://api.opensensemap.org/boxes/${senseBox_ID}/data)
        fi

        if [[ "$OSEM_TRANSMIT" == "\"Measurements saved in box\"" ]]; then
          SAPI "Single" "set/${DP_OSEM_TRANSMIT}?value=true&ack=true"
        else
          SAPI "Single" "set/${DP_OSEM_TRANSMIT}?value=false&ack=true"
        fi
}


osem_register() {
  if [ ${openSenseMap} == "true" ]; then echo -e "\n${RE} [FEHLER:]   ABBRUCH! \"openSenseMap\" ist in der Konfiguration auf 'true' gesetzt!\n\e[0m"; exit; fi

  #benötigter jq installiert?
   if [ ! $(which jq) ]; then
        echo -en "\n\n${WE} Benötigter ${GR}jq${WE} ist auf dem System nicht installiert? Soll er nun installiert werden? [${GR}J/N${WE}]: "
        read -n 1 JN
        if [ $JN != "J" ]; then echo -e " \n$RE Abbruch... ${WE}\n\n"; exit; fi
        sudo apt-get install jq
   fi

  #Abfragen
   clear
        echo -en "\n$WE Neuen SenseBox-User registrieren [${GR}Ja/Nein${WE}]: $GE"
        read JN
        if [ ! $JN ]; then JN="Nein"; fi
        if [ $JN == "Ja" ]; then
         #bereits ein User angelegt
         if [ "$senseBox_USER" != "" ]; then echo -e "\n${RE} [FEHLER:]   ABBRUCH! Es ist bereits ein Username für OpenSenseMap in der Konfiguration gesetzt!\n\e[0m"; exit 1; fi

         echo -e "\n$WE Voller Name oder Nickname. 3-40 Zeichen lang. Erlaubt sind die Zeichen (${GR}a-zA-Z0-9${WE}), Punkte (${GR}.${WE}), Striche (${GR}-${WE}) und Unterstriche (${GR}_${WE})."
         echo -en " Das erste Zeichen muss ein Buchstabe oder eine Ziffer sein: $GE"
         read OSEM_USER
         echo -en "\n$WE gültige Email-Adresse: $GE"
         read OSEM_EMAIL
         echo -en "\n$WE Passwort (mind. 8 Zeichen. Erlaubte Zeichen wie bei Name): $GE"
         read OSEM_PWD
         echo -en "\n$WE Sprache [${GR}d${WE}]eutsch / [${GR}e${WE}]nglisch: $GE"
         read OSEM_LANG
         if [ $OSEM_LANG == "d" ]; then OSEM_LANG=de_DE; OSEM_LANG_OUT=Deutsch; else OSEM_LANG=en_US; OSEM_LANG_OUT=Englisch; fi

         echo -e "\n\n\n$WE Username     :$GE $OSEM_USER"
         echo -e "$WE Email-Adresse:$GE $OSEM_EMAIL"
         echo -e "$WE Passwort     :$GE $OSEM_PWD"
         echo -e "$WE Sprache      :$GE $OSEM_LANG_OUT"

         echo -en "\n$WE Alle Eingaben korrekt [${GR}J/N${WE}]: $GE"
         read JN
         if [ ! $JN ]; then JN="N"; fi
         if [ $JN != "J" ]; then osem_register; fi
                echo -en "\n\n$BL Lege neuen SenseBox-User an..."
                NEW_USER=$(curl -s -d "{\"name\":\"$OSEM_USER\", \"email\":\"$OSEM_EMAIL\", \"password\":\"$OSEM_PWD\", \"language\":\"$OSEM_LANG\"}" \
                 -H "Content-Type: application/json" https://api.opensensemap.org/users/register)

                OSEM_CODE=$(echo $NEW_USER | jq -r '.code')
                OSEM_MESSAGE=$(echo $NEW_USER | jq -r '.message')

                if [ $OSEM_CODE == "UnprocessableEntity" ]; then echo -e "$RE !...Fehler...!"; echo -e "$RE Fehlermeldung: $OSEM_MESSAGE\n"; exit; fi
		#User anlegen hat funktioniert
		echo -e "$GR OK "
		echo -en "$BL Speichere User und Passwort in wetterstation.conf ab..."
		sed -i "s/senseBox_USER=/senseBox_USER=$OSEM_USER/" ./wetterstation.conf
		sed -i "s/senseBox_PWD=/senseBox_PWD=\"$OSEM_PWD\"/" ./wetterstation.conf
		echo -e "$GR OK "

		echo -e "$BL Vor dem fortfahren nun bitte zuerst die Email-Adresse verifizieren (Email von OpenSenseMap im Posteingang)..."
		exit

	elif [ $JN == "Nein" ]; then
	 #dummy
	 echo -en "\n\n"
	else
	 echo -en "\n$RE Keine gültige Antwort: \"$JN\"\n\n"
	 exit
	fi

  ###neue SenseBox registrieren
	echo -en "$WE Neue SenseBox registrieren [${GR}Ja/Nein${WE}]: $GE"
	read JN
	if [ ! $JN ]; then JN="Nein"; fi
	if [ $JN == "Ja" ]; then

	echo -en "$WE Bezeichnung der SenseBox (üblicherweise Standort wie bspw.$GR Berlin Kudamm$WE): $GE"
	read OSEM_SB_NAME
	echo -en "$WE Breitengrad / Latitude der Station (${GR}-90 bis 90${WE}): $GE"
	read OSEM_LAT
	echo -en "$WE Längengrad / Longitude der Station (${GR}-180 bis 180${WE}): $GE"
	read OSEM_LNG
	echo -en "$WE Höhe der Station über Meeresgrund (${GR}GPS, nicht über Grund!${WE}): $GE"
	read OSEM_HOEHE

	#in Opensensemap einloggen + Token speichern
	osem_login


	#neue SenseBox anlegen
	echo -en "\n$BL Neue SenseBox registrieren..."
	NEW_BOX=$(curl -s -d "{\"name\":\"$OSEM_SB_NAME\", \"exposure\":\"outdoor\", \"location\": {\"lat\": $OSEM_LAT, \"lng\": $OSEM_LNG, \"height\": $OSEM_HOEHE}, \"sensors\":[{\"title\":\"Temperatur\", \"unit\":\"°C\", \"sensorType\":\"Wetterstation\",\"icon\":\"osem-thermometer\"}] }" \
        -H "Content-Type: application/json" -H "Authorization: Bearer ${TOKEN}" https://api.opensensemap.org/boxes)
	OSEM_CODE=$(echo $NEW_BOX | jq -r '.code')
	OSEM_MESSAGE=$(echo $NEW_BOX | jq -r '.message')

	if [ $OSEM_CODE == "UnprocessableEntity" ]; then echo -e "$RE !...Fehler...!"; echo -e "$RE Fehlermeldung: $OSEM_MESSAGE\n"; exit; fi
	echo -e "$GR OK "

	#aus OpenSenseMap ausloggen
	echo -e "\n\n\n$WE Nun bitte in OpenSenseMap mittels User $GR$senseBox_USER$WE und Passwort $GR$senseBox_PWD$WE einloggen"
	echo -e " und die SenseBox-ID und den Security-Token der SenseBox in die \"${GR}wetterstation.conf${WE}\" eintragen.\n\n"
	osem_logout
	exit
	fi

	#Sensoren nun reggen
	echo -en "\n\n$WE Sensoren nun registrieren [${GR}Ja/Nein${WE}]: $GE"
	read JN
	if [ ! $JN ]; then JN="Nein"; fi
	if [ $JN == "Ja" ]; then
		echo -e "\n$BL Registriere nun Sensoren in der SenseBox...\e[s"
		osem_login; echo

		for ((i=1;i<${#SENSEBOX_IDNAME[@]};i++)); do
		  SENSOR_DATA="$SENSOR_DATA{\"edited\":\"true\", \"new\":\"true\", \"title\":\"${SENSEBOX_IDNAME[i]}\", \"unit\":\"${UNITS[i]}\", \"sensorType\":\"Wetterstation\",\"icon\":\"${ICONS[i]}\"},"
		done
		SENSOR_DATA="{\"sensors\":["${SENSOR_DATA%,}"]}"
		NEW_SENSORS=$(curl -s -X PUT -H 'Content-Type: application/json' -H "Authorization: Bearer ${TOKEN}" \
		  -d "$SENSOR_DATA" https://api.opensensemap.org/boxes/${senseBox_ID})
		OSEM_CODE=$(echo $NEW_SENSORS | jq -r '.code')
		OSEM_MESSAGE=$(echo $NEW_SENSORS | jq -r '.message')
		if [ $OSEM_CODE != "Ok" ]; then echo -e "$RE !...Fehler...!"; echo -e "$RE Fehlermeldung: $OSEM_MESSAGE\n"; exit; fi
		let ii+=3; echo -e "\e[u$GR OK $WE\e[${ii}B"


		SENSOREN_IDs=($(curl -s https://api.opensensemap.org/boxes/${senseBox_ID} | jq -r ".sensors|.[]._id"))
		let ii=0
		for i in "${SENSEBOX_IDNAME[@]}"
		 do
		  echo -e "$BL SensorID für Sensor $GE$i$BL\e[1C\t: ${GR}${SENSOREN_IDs[ii]}${WE}"
		  SENSOR_tmpS="$SENSOR_tmpS${SENSOREN_IDs[ii]} "
		  let ii++
		 done
		sed -i "s/SENSEBOX_IDSENSOR=()/SENSEBOX_IDSENSOR=(${SENSOR_tmpS% })/" ./wetterstation.conf

		#nun OSEM aktivieren und service neu starten
		osem_logout
		echo -en "\n$WE OpenSensMap nun aktivieren und den Wetterstation.service neu starten [${GR}Ja/Nein${WE}]? $GE"
		read JN
		if [ ! $JN ]; then JN="Nein"; fi
		if [ $JN == "Ja" ]; then
		 sed -i "s/openSenseMap=false/openSenseMap=true/" ./wetterstation.conf
		 if [ -f /etc/systemd/system/wetterstation.service ]; then
			sudo systemctl restart wetterstation
		  else
			echo -e "\n$RE Wetterstation läuft nicht als Service. Bitte von Hand neu starten...$WE"
		 fi
		 echo -e "\n$GR Done...$WE"
		fi
	fi

 echo -e "\n"
 exit
}


osem_login() {
	echo -en "\n$BL Einloggen in OpenSenseMap und Token beziehen..."
	MESSAGE=$(curl -s -d "{\"email\":\"$senseBox_USER\", \"password\":\"$senseBox_PWD\"}" -H 'Content-Type: application/json' https://api.opensensemap.org/users/sign-in)
 	TOKEN=$(echo $MESSAGE | jq -r '.token')
	OSEM_MESSAGE=$(echo $MESSAGE | jq -r '.message')

	if [[ "$OSEM_MESSAGE" == "Successfully signed in" ]]; then
	  echo -e "$GR OK "
         else
          echo -e "$RE !...Fehler...!"
	  echo -e "$RE Fehlermeldung: \"$OSEM_MESSAGE\"\n"
	  exit
	fi
}

osem_logout() {
	echo -en "\n$BL Ausloggen von OpenSenseMap..."
	SIGN_OUT=$(curl -s -d '' -H "Authorization: Bearer ${TOKEN}" https://api.opensensemap.org/users/sign-out)
	LOGOFF=$(echo $SIGN_OUT | jq -r '.code')
	OSEM_MESSAGE=$(echo $SIGN_OUT | jq -r '.message')
	if [ $LOGOFF == "Ok" ]; then
          echo -e "$GR OK "
         else
          echo -e "$RE !...Fehler...!"
          echo -e "$RE Fehlermeldung: \"$OSEM_MESSAGE\"\n"
          exit
        fi
}


hitzeindex() {
    bc -l <<END_BC
        define hitzeindex(temp,feuchte)
        {
            number = -8.784695
            number += 1.61139411 * temp
            number += 2.338549 * feuchte
            number -= 0.14611605 * temp * feuchte
            number -= 0.012308094 * (temp ^2)
            number -= 0.016424828 * (feuchte ^2)
            number += 0.002211732 * (temp ^2) * feuchte
            number += 0.00072546 * temp * (feuchte ^2)
            number -= 0.000003582 * (temp ^2) * (feuchte ^2)
            return number
        }
        hitzeindex ($1,$2)
END_BC
}


minmax24h() {
        MIN_TEMP_24H=$(curl -sG "http://${INFLUX_API}/query?pretty=true" --data-urlencode "epoch=s" --data-urlencode "db=${INFLUX_DB}" \
        --data-urlencode "u=${INFLUX_USER}" --data-urlencode "p=${INFLUX_PASSWORD}" \
        --data-urlencode "q=SELECT min(value) FROM \"${PRE_DP}.Aussentemperatur\" WHERE time >= now() - 1d" |\
        jq -r '.results | .[].series | .[].values[] | .[1]')
        MAX_TEMP_24H=$(curl -sG "http://${INFLUX_API}/query?pretty=true" --data-urlencode "epoch=s" --data-urlencode "db=${INFLUX_DB}" \
        --data-urlencode "u=${INFLUX_USER}" --data-urlencode "p=${INFLUX_PASSWORD}" \
        --data-urlencode "q=SELECT max(value) FROM \"${PRE_DP}.Aussentemperatur\" WHERE time >= now() - 1d" |\
        jq -r '.results | .[].series | .[].values[] | .[1]')

        SAPI "Single" "set/${DP_MIN_TEMP_24H}?value=${MIN_TEMP_24H}&ack=true"
        SAPI "Single" "set/${DP_MAX_TEMP_24H}?value=${MAX_TEMP_24H}&ack=true"
}


minmaxheute() {
        local TIMESTAMP=$(date +%Y-%m-%d)" 00:00:00"
        MIN_TEMP_HEUTE=$(curl -sG "http://${INFLUX_API}/query?pretty=true" --data-urlencode "epoch=s" --data-urlencode "db=${INFLUX_DB}" \
        --data-urlencode "u=${INFLUX_USER}" --data-urlencode "p=${INFLUX_PASSWORD}" \
        --data-urlencode "q=SELECT min(value) FROM \"${PRE_DP}.Aussentemperatur\" WHERE time <= now() and time >= '${TIMESTAMP}'" |\
        jq -r '.results | .[].series | .[].values[] | .[1]')
        MAX_TEMP_HEUTE=$(curl -sG "http://${INFLUX_API}/query?pretty=true" --data-urlencode "epoch=s" --data-urlencode "db=${INFLUX_DB}" \
        --data-urlencode "u=${INFLUX_USER}" --data-urlencode "p=${INFLUX_PASSWORD}" \
        --data-urlencode "q=SELECT max(value) FROM \"${PRE_DP}.Aussentemperatur\" WHERE time <= now() and time >= '${TIMESTAMP}'" |\
        jq -r '.results | .[].series | .[].values[] | .[1]')

        #keine Werte vorhanden?
        if [ -z ${MIN_TEMP_HEUTE} ] || [ -z ${MAX_TEMP_HEUTE} ]; then
           MIN_TEMP_HEUTE=${MESSWERTE[1]}
           MAX_TEMP_HEUTE=${MESSWERTE[1]}
        fi

        SAPI "Single" "set/${DP_MIN_TEMP_HEUTE}?value=${MIN_TEMP_HEUTE}&ack=true"
        SAPI "Single" "set/${DP_MAX_TEMP_HEUTE}?value=${MAX_TEMP_HEUTE}&ack=true"
}


minmaxavg365d() {
     if [ ! -z ${INFLUX_DB} ]; then
        MIN_TEMP_365D=$(curl -sG "http://${INFLUX_API}/query?pretty=true" --data-urlencode "epoch=s" --data-urlencode "db=${INFLUX_DB}" \
        --data-urlencode "u=${INFLUX_USER}" --data-urlencode "p=${INFLUX_PASSWORD}" \
        --data-urlencode "q=SELECT min(value) FROM \"${PRE_DP}.Aussentemperatur\" WHERE time >= now() - 366d AND time <= now() - 365d" |\
        jq -r '.results | .[].series | .[].values[] | .[1]' 2> /dev/null)
        if [ -z "${MIN_TEMP_365D}" ]; then
          SAPI "Single" "set/${DP_MIN_TEMP_365D}?value=-99.99&ack=true"
         else
          SAPI "Single" "set/${DP_MIN_TEMP_365D}?value=${MIN_TEMP_365D}&ack=true"
        fi

        MAX_TEMP_365D=$(curl -sG "http://${INFLUX_API}/query?pretty=true" --data-urlencode "epoch=s" --data-urlencode "db=${INFLUX_DB}" \
        --data-urlencode "u=${INFLUX_USER}" --data-urlencode "p=${INFLUX_PASSWORD}" \
        --data-urlencode "q=SELECT max(value) FROM \"${PRE_DP}.Aussentemperatur\" WHERE time >= now() - 366d AND time <= now() - 365d" |\
        jq -r '.results | .[].series | .[].values[] | .[1]' 2> /dev/null)
        if [ -z "${MAX_TEMP_365D}" ]; then
          SAPI "Single" "set/${DP_MAX_TEMP_365D}?value=-99.99&ack=true"
         else
          SAPI "Single" "set/${DP_MAX_TEMP_365D}?value=${MAX_TEMP_365D}&ack=true"
        fi

        AVG_TEMP_365D=$(curl -sG "http://${INFLUX_API}/query?pretty=true" --data-urlencode "epoch=s" --data-urlencode "db=${INFLUX_DB}" \
        --data-urlencode "u=${INFLUX_USER}" --data-urlencode "p=${INFLUX_PASSWORD}" \
        --data-urlencode "q=SELECT mean(value) FROM \"${PRE_DP}.Aussentemperatur\" WHERE time >= now() - 366d AND time <= now() - 365d" |\
        jq -r '.results | .[].series | .[].values[] | .[1]' 2> /dev/null)
        if [ -z "${AVG_TEMP_365D}" ]; then
          SAPI "Single" "set/${DP_AVG_TEMP_365D}?value=-99.99&ack=true"
         else
          AVG_TEMP_365D=$(round ${AVG_TEMP_365D} 2)
          SAPI "Single" "set/${DP_AVG_TEMP_365D}?value=${AVG_TEMP_365D}&ack=true"
        fi

     fi
}


metsommer() {
     if [ ! -z ${INFLUX_DB} ]; then
      if [ $(date +%m) -ge "6" ] && [ $(date +%m) -le "8" ] || [ ! -z ${metsom_override} ]; then
        if [ $(date +%m) -le "5" ]; then echo -e "\n ${RE}Eine Berechnung der meteorologischen Sommerwerte kann für das aktuelle Jahr $(date +%Y) erst ab dem 01. Juni durchgeführt werden!${NO}\n";exit 1; fi
        local TIMESTART=$(date +%Y-06-01)" 00:00:00"
        local TIMESTOP=$(date +%Y-08-31)" 23:59:59"

        MET_SOMMER_TEMP_AVG=$(curl -sG "http://${INFLUX_API}/query?pretty=true" --data-urlencode "epoch=s" --data-urlencode "db=${INFLUX_DB}" \
        --data-urlencode "u=${INFLUX_USER}" --data-urlencode "p=${INFLUX_PASSWORD}" \
        --data-urlencode "q=SELECT mean(value) FROM \"${PRE_DP}.Aussentemperatur\" WHERE time >= '${TIMESTART}' AND time <= '${TIMESTOP}'" |\
        jq -r '.results | .[].series | .[].values[] | .[1]' 2> /dev/null)
        if [ -z "${MET_SOMMER_TEMP_AVG}" ]; then
          SAPI "Single" "set/${DP_MET_SOMMER_TEMP}?value=99.99&ack=true"
         else
          MET_SOMMER_TEMP_AVG=$(round ${MET_SOMMER_TEMP_AVG} 2)
          SAPI "Single" "set/${DP_MET_SOMMER_TEMP}?value=${MET_SOMMER_TEMP_AVG}&ack=true"
        fi

        declare -a MET_SOMMER_REGEN_ARR
        MET_SOMMER_REGEN_ARR=$(curl -sG "http://${INFLUX_API}/query?pretty=true" --data-urlencode "epoch=s" --data-urlencode "db=${INFLUX_DB}" \
        --data-urlencode "u=${INFLUX_USER}" --data-urlencode "p=${INFLUX_PASSWORD}" \
        --data-urlencode "q=SELECT max(value) FROM \"${PRE_DP}.Regen_Tag\" WHERE (time >= '${TIMESTART}' AND time <= '${TIMESTOP}') group by time(1d)" |\
        jq -r '.results | .[].series | .[].values[] | .[1]' 2> /dev/null)
        #Summe des Arrays bilden
         MET_SOMMER_REGEN=0
         for i in ${MET_SOMMER_REGEN_ARR[@]}; do
          MET_SOMMER_REGEN=$(echo "scale=1; ${MET_SOMMER_REGEN}+$i" | bc -l)
         done

        if [ -z "${MET_SOMMER_REGEN}" ]; then
          SAPI "Single" "set/${DP_MET_SOMMER_REGEN}?value=999.9&ack=true"
         else
          SAPI "Single" "set/${DP_MET_SOMMER_REGEN}?value=${MET_SOMMER_REGEN}&ack=true"
        fi


        if [ ! -z ${metsom_override} ]; then
          echo -e "\n Daten vom 01.06.$(date +%Y) bis 31.08.$(date +%Y) wurden ermittelt...\n"
          echo -e "\t Ø-Temperatur: ${GR}${MET_SOMMER_TEMP_AVG} °C${NO}"
          echo -e "\t Regenmenge  : ${GR}${MET_SOMMER_REGEN} l/m²${NO}\n"
        fi
        unset MET_SOMMER_REGEN_ARR
        unset metsom_override

      fi
     fi
}


logging() {
      local DATUM=$(date '+%Y%m%d')
      echo -e "\n${DATA}" >> "${DIR}/${DATUM}_station.log"
}


WH31() {
      #WH31-Sensoren
      if [[ ${MESSWERTERAWIN[$i]} =~ ^wh25batt= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
}


DP40() {
      #DP40-Sensoren
      if [[ ${MESSWERTERAWIN[$i]} =~ ^wh26batt= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
}


DP50_100() {
      #DP50/100-Sensoren
      if [[ ${MESSWERTERAWIN[$i]} =~ ^temp[1-8]f= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
         convertFtoC $j
      fi
      if [[ ${MESSWERTERAWIN[$i]} =~ ^humidity[1-8]= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
      if [[ ${MESSWERTERAWIN[$i]} =~ ^batt[1-8]= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
      if [[ ${MESSWERTERAWIN[$i]} =~ ^soilbatt[1-8]= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
      if [[ ${MESSWERTERAWIN[$i]} =~ ^soilmoisture[1-8]= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
}


DP60() {
      #DP60-Sensor
      if [[ ${MESSWERTERAWIN[$i]} == lightning=* ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
      if [[ ${MESSWERTERAWIN[$i]} == lightning_num=* ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
      if [[ ${MESSWERTERAWIN[$i]} == lightning_time=* ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
         #um Nanosekunden erweitern
         MESSWERTE[$j]=$(echo ${MESSWERTE[$j]}000)
      fi
      if [[ ${MESSWERTERAWIN[$i]} == wh57batt=* ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
}


DP70() {
      #DP70-Sensoren
      if [[ ${MESSWERTERAWIN[$i]} =~ ^leak_ch[1-4]= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
         leakalarm $j
      fi
      if [[ ${MESSWERTERAWIN[$i]} =~ ^leakbatt[1-4]= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
}


DP200() {
      #DP200-Sensoren
      if [[ ${MESSWERTERAWIN[$i]} =~ ^pm25_ch[1-4]= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
      if [[ ${MESSWERTERAWIN[$i]} =~ ^pm25_avg_24h_ch[1-4]= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
      if [[ ${MESSWERTERAWIN[$i]} =~ ^pm25batt[1-4]= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
}


DP250() {
      #DP250/WH45-Sensor
      if [[ ${MESSWERTERAWIN[$i]} =~ ^tf_co2= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
         convertFtoC $j
      fi
      if [[ ${MESSWERTERAWIN[$i]} =~ ^humi_co2= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
      if [[ ${MESSWERTERAWIN[$i]} =~ ^pm25_co2= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
      if [[ ${MESSWERTERAWIN[$i]} =~ ^pm25_24h_co2= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
      if [[ ${MESSWERTERAWIN[$i]} =~ ^pm10_co2= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
      if [[ ${MESSWERTERAWIN[$i]} =~ ^pm10_24h_co2= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
      if [[ ${MESSWERTERAWIN[$i]} =~ ^co2= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
      if [[ ${MESSWERTERAWIN[$i]} =~ ^co2_24h= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
      if [[ ${MESSWERTERAWIN[$i]} =~ ^co2_batt= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
}


DP300() {
      #DP300-Sensoren
      if [[ ${MESSWERTERAWIN[$i]} =~ ^wh68batt= ]]
         then let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f1)
         let "j++"
         MESSWERTE[$j]=$(echo ${MESSWERTERAWIN[$i]}|cut -d"=" -f2)
      fi
}


windy_register(){
      #Registrierung einer Station bei Windy
      clear
           echo -e " $GE┌────────────────────────────────────────────────────────────┐"
           echo -e " │                                                            │"
           echo -e " │  ${WE}Zur Registrierung einer Station ist vorher ein            ${GE}│"
           echo -e " │  ${WE}Account bei Windy nötig!                                  ${GE}│"
           echo -e " │  ${WE}([ENTER] übernimmt immer den Default-Wert)                ${GE}│"
           echo -e " │                                                            │"
           echo -e " │  ${WE}Soll nun eine Station registriert werden? [${GR}J/N${WE}]\033[s           ${GE}│"
           echo -e " │                                                            │"
           echo -e " └────────────────────────────────────────────────────────────┘"
           echo -en "\033[u${GR}"
           read -n 1 -p ": " JN
           if [ "$JN" = "J" ] || [ "$JN" = "j" ]; then
             echo -e "\n\n\n"
            else
             echo -e "\n\n\n"
             echo -e " $RE Abbruch... ${WE}\n\n\n"; exit;
           fi

   #Station anlegen
           #API-Key
            echo -en "$WE API-Key von Windy (https://stations.windy.com/stations): $GR\033[s"
            read windy_apikey
            if [ ! $windy_apikey ]; then echo -e "\033[u $RE Abbruch..."; echo -e "\n Ohne API-Key kann keine Station angelegt werden!\n\n"; exit 1; fi
           #Station
            echo -en "$WE Nummer der Station [${GR}0 - 2147483647${WE}] / default: 0 (für die erste Station): $GR\033[s"
            read windy_station
            if [ ! $windy_station ]; then windy_station=0; echo -e "\033[u$windy_station"; fi
           #shareOption
            echo -e "\n$WE Daten-Cloud [${GR}1-3${WE}] / default: 1 (Open):"
            echo -e "   ${GR}1${WE} - Open (Daten für alle zugänglich)"
            echo -e "   ${GR}2${WE} - Only Windy (Daten nur für Windy zugänglich)"
            echo -e "   ${GR}3${WE} - Private (Daten nur für einen selbst zugänglich)"
            echo -en "\n   Auswahl: $GR\033[s"
            read windy_shareOption
            case $windy_shareOption in
             1) windy_shareOption="Open";;
             2) windy_shareOption="Only Windy";;
             3) windy_shareOption="Private";;
             *) windy_shareOption="Open"
            esac
            echo -e "\033[u${windy_shareOption}"
           #Name
            echo -en "\n$WE Name der Station [${GR}Text${WE}]: $GR"
            read windy_name
            echo -e "\n ${GE}Die folgenden Angaben sind nötig, ansonsten kann die Station nicht registriert werden!"
           #Latitude (Nord-Süd)
            echo -en "\n$WE Latitude/Breitengrad der Station [${GR}Nummer${WE}] °: $GR\033[s"
            read windy_lat
            if [ ! $windy_lat ]; then echo -e "\033[uEingabe notwendig! $RE Abbruch..."; exit 1; fi
           #Longitude (Ost-West)
            echo -en "\n$WE Longitude/Längengrad der Station [${GR}Nummer${WE}] °: $GR\033[s"
            read windy_long
            if [ ! $windy_long ]; then echo -e "\033[uEingabe notwendig! $RE Abbruch..."; exit 1; fi
           #Elevation
            echo -en "\n$WE Höhe der Station über Meereshöhe [${GR}Nummer${WE}] m: $GR\033[s"
            read windy_elev
            if [ ! $windy_elev ]; then echo -e "\033[uEingabe notwendig! $RE Abbruch..."; exit 1; fi
           #Tempheight
            echo -en "\n$WE Montagehöhe des Temperatursensors über dem Boden [${GR}Nummer${WE}] m: $GR\033[s"
            read windy_tempheight
            if [ ! $windy_tempheight ]; then echo -e "\033[uEingabe notwendig! $RE Abbruch..."; exit 1; fi
           #Windheight
            echo -en "\n$WE Montagehöhe des Windsensors über dem Boden [${GR}Nummer${WE}] m: $GR\033[s"
            read windy_windheight
            if [ ! $windy_windheight ]; then echo -e "\033[uEingabe notwendig! $RE Abbruch..."; exit 1; fi


         echo -e "\n\n\n ${WE}Ihre Angaben:\n"
         echo -e "${BL}  Nummer der Station\t\t: ${GR}$windy_station"
         echo -e "${BL}  Daten-Cloud\t\t\t: ${GR}$windy_shareOption"
         echo -e "${BL}  Name der Station\t\t: ${GR}$windy_name"
         echo -e "${BL}  Latitude der Station\t\t: ${GR}${windy_lat}°"
         echo -e "${BL}  Longitude der Station\t\t: ${GR}${windy_long}°"
         echo -e "${BL}  Höhe der Station ÜNN\t\t: ${GR}${windy_elev}m"
         echo -e "${BL}  Montagehöhe Temperatursensor\t: ${GR}${windy_tempheight}m"
         echo -e "${BL}  Montagehöhe Windsensor\t: ${GR}${windy_windheight}m"
         echo -en "\n${WE} Alles richtig und Station nun anlegen? [${GR}J/N${WE}]"
           read -n 1 -p ": " JN
           if [ "$JN" = "J" ] || [ "$JN" = "j" ]; then
             echo -e "\n\n\n"
            else
             echo -e "\n\n\n"
             echo -e " $RE Abbruch... ${WE}\n\n\n"; exit 1;
           fi

        #Station anlegen
         windy_data="{\"stations\":[{\"station\":${windy_station}, \"name\":\"${windy_name}\", \"shareOption\":\"${windy_shareOption}\", \"lat\":${windy_lat}, \"lon\":${windy_long}, "
         windy_data+="\"elevation\":${windy_elev}, \"tempheight\":${windy_tempheight}, \"windheight\":${windy_windheight}}]}"
         echo ${windy_data}>windy_tmp
         curl -X POST -H "Content-Type: application/json" https://stations.windy.com/pws/update/${windy_apikey} -d @windy_tmp
         rm windy_tmp

        #Daten in die Konfiguration übernehmen
         echo -e "\n$WE ... bearbeite \"wetterstation.conf\"\n"
         sed -i "s/windy_APIKey=/windy_APIKey=${windy_apikey}/" ./wetterstation.conf
         sed -i "s/windy_Station=/windy_Station=${windy_station}/" ./wetterstation.conf
         sed -i "s/windy_Name=/windy_Name=${windy_name}/" ./wetterstation.conf
         sed -i "s/windy_Latitude=/windy_Latitude=${windy_lat}/" ./wetterstation.conf
         sed -i "s/windy_Longitude=/windy_Longitude=${windy_long}/" ./wetterstation.conf
         sed -i "s/windy_Elevation=/windy_Elevation=${windy_elev}/" ./wetterstation.conf
         sed -i "s/windy_Tempheight=/windy_Tempheight=${windy_tempheight}/" ./wetterstation.conf
         sed -i "s/windy_Windheight=/windy_Windheight=${windy_windheight}/" ./wetterstation.conf

        #Windy aktivieren
		echo -en "\n$WE Windy nun aktivieren und den Wetterstation.service neu starten [${GR}Ja/Nein${WE}]? $GE"
		read JN
		if [ ! $JN ]; then JN="Nein"; fi
		if [ $JN == "Ja" ]; then
		 sed -i "s/use_windy=false/use_windy=true/" ./wetterstation.conf
		 if [ -f /etc/systemd/system/wetterstation.service ]; then
			sudo systemctl restart wetterstation
		  else
			echo -e "\n$RE Wetterstation läuft nicht als Service. Bitte von Hand neu starten...$WE"
		 fi
		 echo -e "\n$GR Done...$WE"
		fi

}



do_windchill(){
   #Taupunkt und Windchill berechnen
   if [ -z ${MESSWERTE[3]} ] && [ ! -z ${MESSWERTE[1]} ] && [ ! -z ${MESSWERTE[6]} ]; then
     if (( $(bc -l <<< "${MESSWERTE[6]} > 5") )) && (( $(bc -l <<< "${MESSWERTE[1]} < 11") )); then
        WINDCHILL=$(echo "scale=4;(13.12 + 0.6215 * ${MESSWERTE[1]} - 11.37 * e(l(${MESSWERTE[6]})*0.16) + 0.3965 * ${MESSWERTE[1]} * e(l(${MESSWERTE[6]})*0.16))/1" | bc -l)
        MESSWERTE[3]=$(round $WINDCHILL 2)
      else
        MESSWERTE[3]=$(echo ${MESSWERTE[1]})
     fi
   fi

   if [ -z ${MESSWERTE[2]} ] && [ ! -z ${MESSWERTE[1]} ] && [ ! -z ${MESSWERTE[5]} ]; then
     TAUPUNKT=$(echo "scale=4;(e(l(${MESSWERTE[5]}/100)*(1/8.02)) * (109.8 + ${MESSWERTE[1]}) - 109.8)/1" | bc -l)
     MESSWERTE[2]=$(round $TAUPUNKT 2)
   fi
}



windy_update(){
        #Daten an die Windy-Cloud senden
         windy_mph=$(echo "scale=2;(${MESSWERTE[6]}*10/36)" | bc -l)
         windy_boe_mph=$(echo "scale=2;(${MESSWERTE[7]}*10/36)" | bc -l)
         windy_DATA="station=${windy_Station}&ts=$(date +%s)&temp=${MESSWERTE[1]}&wind=${windy_mph}&mbar=${MESSWERTE[9]}&winddir=${MESSWERTE[8]}"
         windy_DATA+="&gust=${windy_boe_mph}&humidity=${MESSWERTE[5]}&dewpoint=${MESSWERTE[2]}&precip=${MESSWERTE[23]}&uv=${MESSWERTE[17]}"
         if [ $debug == "true" ]; then
           echo -e "\n${BL}Datenübertragung an windy.com:${NO}"
            curl https://stations.windy.com/pws/update/${windy_APIKey}?${windy_DATA}
           return 0 #Ausgang
          else
            local retval=$(curl -s https://stations.windy.com/pws/update/${windy_APIKey}?${windy_DATA})
          fi
         if echo ${retval}|grep -q 'SUCCESS'; then
             SAPI "Single" "set/${DP_WINDY_TRANSMIT}?value=true&ack=true"
           else
             SAPI "Single" "set/${DP_WINDY_TRANSMIT}?value=false&ack=true"
         fi
}



wettercom_update(){
        #Daten an wetter.com senden
        WC_URL="http://www.wetterarchiv.de/interface/http/input.php?benutzername=${WETTERCOM_ID}&passwort=${WETTERCOM_PW}"
        #Sommer-/Winterzeit - Patch
        if date|grep -q 'CET'; then
          local TIMESTAMP=$(date +%Y%m%d%H%M --date='+1 hour')
         else
          local TIMESTAMP=$(date +%Y%m%d%H%M)
        fi

        local WIND=$(echo "scale=4;${MESSWERTE[6]}/3.6" | bc -l)
        WC_URL+="&datum=${TIMESTAMP}&temperatur=${MESSWERTE[1]}&feuchtigkeit=${MESSWERTE[5]}&windrichtung=${MESSWERTE[8]}"
        WC_URL+="&windstaerke=${WIND}&luftdruck=${MESSWERTE[10]}&niederschlagsmenge=${MESSWERTE[11]}"
        if [ $debug == "true" ]; then
           echo -e "\n\n${BL}Datenübertragung an wetter.com:"
           echo -e "${RE}(vor einer Veröffentlichung unbedingt zumindest das Passwort unkenntlich machen, ggf. auch die Station-ID[=Benutzername])${NO}"
           wget -O- "${WC_URL}"
           return 0 #Ausgang
         else
           local MESSAGE=$(wget -qO- "${WC_URL}")
        fi

        #alles Ok?
        if echo ${MESSAGE}|grep -q 'SUCCESS'; then
           SAPI "Single" "set/${DP_WCOM_TRANSMIT}?value=true&ack=true"
         else
           SAPI "Single" "set/${DP_WCOM_TRANSMIT}?value=false&ack=true"
        fi
}

###EoF


